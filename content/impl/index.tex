\section{Implementation}
\label{sec:implementation}
We implement the beacon as  a set of independent components with their own responsibilities. Each component communicates with the others by sending and receiving messages, but are capable of running by themselves. We have four types of components, each with separate responsibilities, and multiple examples of some certain types.
The first type is the \emph{input collector}, responsible for collecting user input, hashing the input and sending it to the next part of the pipeline. We have three components of this type, one for receiving HTTP input, one for TCP input, and a Telegram Messenger bot. Each of these allow users to provide input to upcoming computations. The input is hashed using SHA-512 for consistency and to prepare for the next step of the pipeline.
The second type is the \emph{input processor}, responsible for processing input before it is used to produce randomness. We have two components of this type, one of which takes a set of inputs and constructs a Merkle tree from them. The root of the Merkle tree is then passed to the next step of the pipeline. The other takes the hashed inputs and concatenates them into a single string.
The third type is the \emph{computation}, that computes the pseudorandom output of our beacon. It implements delay function based on the Sloth function used in \cite{randomzoo} to ensure that the randomness takes a large amount of time, and is resistant to being pre-computed.
The fourth and final type is the \emph{output publisher}, responsible for publishing the randomness and proof for users. We have a single component of this type, namely a Twitter bot that publishes a random number alongside a sequence number for identification.

\subsection{Technologies}
\label{sub:technologies}
These are some key technologies and their advantages and drawbacks.
We implement the beacon in Python for its ease of use, allowing us to rapidly develop and modify the beacon. We use ZeroMQ to facilitate communication between by message passing between components, and it also allows us to initialize each component independently of each other. \mtjnote{TODO: Describe what ZeroMQ is.}
We use hashing algorithms prominently throughout the beacon. Inputs are hashed for the input processor, which in turn constructs a Merkle tree composed of hashes compounding up to the root node. The output is also a 512-bit hash, which can easily be shared and used. Using hashes allows users to contribute arbitrary data, as all inputs will be hashed into similar formats before being passed on in the pipeline. This also contains any negative effects that could arise from user inputs to the input collectors, as anything that is sent is in a pre-defined format.