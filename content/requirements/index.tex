\section{Definition}

\mtjnote{THIS IS DIRECTLY FROM PREVIOUS SEMESTER}

%A randomness beacon is a service that publishes random data at a known interval.
Formally, let $B: f(I_t) \rightarrow O_t$, where $B$ is a beacon, $I_t$ is the input at time $t$, $O_t$ is the output at time $t$, and $f$ is a suitable function for transforming the input to the output.
For $B$ to be a beacon, it is run at a known, regular interval, $\delta$, such that $t+n\delta$ for any $n \in \mathbb{N}$ are valid output intervals for the beacon.
In \Vref{fig:abstract_beacon} an example of an abstract beacon can be seen.
The green area is what can be defined as the beacon, or \emph{beacon protocol} --- i.e.\ how input is collected, transformed to output and then published.

\subimport{}{simple_beacon_fig.tex}


It consists of a round of input collection with a known deadline. At the deadline, input collection is stopped, and computation can begin. Meanwhile a new round of input collection can begin???

\section{Randomness Beacon Requirements}
\label{sec:beacon_requirements}

We believe randomness beacons are universal --- a sufficiently general randomness beacon with enough entropy can be utilized for multiple use cases. Given the many use cases, we will therefore prioritize a use case agnostic beacon.
This means that some requirements may be more relaxed in our case, compared to a specialized randomness beacon, suited for one use case only. However, the usefulness of such general randomness beacon is much higher as it can serve multiple use cases.

The requirements of our randomness beacon are separated into two groups: functional and non-functional requirements, as suggested by \citet[sec.\ 1.4.1]{swebok} \mtjnote{Or Sommerville if you guys prefer... Same same}.

\subsection{Functional Requirements}
\label{sub:functional_requirements}
\begin{description}
    \item[Modular Input and Output] The input and output channels of the randomness beacon should be extensible or configurable by beacon operators. This will allow a beacon operator to use their preferred input sources and output channels. For example, a beacon operator may allow users to provide inputs through TCP/IP, email, and even tweets. Similarly the output may be tweeted, published on a website, or both.

    \item[Deterministic Randomness] The beacon should be able to deterministically compute a random output from a set of inputs.

    \item[Commitment to Input] The beacon should produce a commitment to a set of inputs and publish the commitment as soon as possible after the input collection deadline, but before initiating output computation. This ensures that the beacon operator cannot add, remove, or order the inputs to his own benefit.

    \item[Output] The beacon should publish the random output immediately after the computation is done, accompanied with any important meta data about the computation, e.g.\ parameters and witnesses to be used in verification.

    \item[Unpredictable] The output should be unpredictable before the computation is done, even for the beacon operator.

    \item[Verifiable] The output should be verifiable for any user, i.e.\ anyone should be able to verify the authenticity of both the computation and origin of the output.
\end{description}

\subsection{Non-Functional Requirements}
\label{sub:non_functional_requirements}

\begin{description}
    \item[No Single Point of Failure] The beacon should not contain a single point of failure, i.e.\ it should be configurable to be fault-tolerant by utilizing redundancy.
    \item[Something something] Operating the beacon should be incentivized and distributable among multiple participants. \msmnote{e.g.\ input sourcing by some, computation by another, etc.} \mtjnote{Why are these two necessary?} \mtjnote{This is two requirements, no?}
    \item[Usability] It should be easy for users to contribute with input, and to fetch outputs. In practice this should not be a major problem, since input can be contributed over an insecure channel (they are not secret), and likewise the output can be retrieved over an insecure channel because the correctness of computation can be verified.
\end{description}

\subsection{Security Requirements}
\mtjnote{Maybe they are in the above functional and non-functional requirements? Maybe re-iterate them. Which requirements are important to the security?}

\mtjnote{Do we want to sign the output with our own signature? We probably do not need it for tamper-detection, as clients using the random number should verify the computation and the presence of their own input. Maybe we should include some random nonce (the operators own input) and then we might need signing to see if the number came from us.}

\mtjnote{Maybe discuss the implications of above requirements. E.g.:}

\mtjnote{We need to discuss the implications of only using insecure channels. What if an adversary has complete knowledge of all inputs? Then he can only do it as fast as the original operator? But he cannot change anything besides the order of inputs --- but he needs to commit to the order before computing, and clients should not use a random number for which they have not seen the corresponding commitment to. So everything is good?}
