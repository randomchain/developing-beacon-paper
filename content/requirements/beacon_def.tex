\section{Beacon Definition}

\mtjnote{THIS IS DIRECTLY FROM PREVIOUS SEMESTER}

%A randomness beacon is a service that publishes random data at a known interval.
\enquote{Formally, let $B: f(I_t) \rightarrow O_t$, where $B$ is a beacon, $I_t$ is the input at time $t$, $O_t$ is the output at time $t$, and $f$ is a suitable function for transforming the input to the output.
For $B$ to be a beacon, it is run at a known, regular interval, $\delta$, such that $t+n\delta$ for any $n \in \mathbb{N}$ are valid output intervals for the beacon.
In \Vref{fig:abstract_beacon} an example of an abstract beacon can be seen.
The green area is what can be defined as the beacon, or \emph{beacon protocol} --- i.e.\ how input is collected, transformed to output and then published.}

\subimport{}{simple_beacon_fig.tex}

%A sufficiently general randomness beacon with enough entropy can be utilized for multiple use cases, and as such is of higher usefulness.
%Given the many use cases, we will therefore prioritize a use case agnostic beacon.

\subsection{Trust Assumptions}

We take the view of \enquote{Everybody, including the beacon operator, is secretly colluding against you and willing to put an unlimited amount of money towards manipulating or biasing the process for their own benefit}.
The only one you can trust is yourself, and this extends to the beacon. If you have not influenced the beacon output, it should be considered biased against you by default. In addition, even if you have influenced the output, given enough time resources to work around your influence, the output could still be biased against you. 

\subsection{A Note on Randomness}
Some randomness beacons claim to produce true randomness~\cite{nistbeacon}.
In our setting, producing true randomness is not an option.
True randomness is often produced by observing quantum mechanical effects.
These observations cannot be repeated by users (they are, after all, truly random and non-reproducible), and therefore users cannot make sure that the value is indeed from observing the quantum mechanical effect and not crafted by the beacon operator.
As such, the users need to blindly trust the beacon operator, which in the case of NIST can be hard given their history\cite{nytimes-nsabackdoors, nytimes-nsaconstants, nist2014backdoor}.

Fortunately, the vast majority of use cases do not actually require true randomness.
Far more desirable is the side effect of producing randomness: \emph{unpredictability}.
As long as the output is unpredictable for all parties including the beacon operator, we do not really need true randomness, and the beacon output can be produced by a deterministic algorithm.
And if implemented correctly, deterministic pseudo-randomness is just as good for virtually all use cases and provides a good level of unpredictability.
%No true randomness is necessary but we care deeply about the unpredictability from deterministic pseudo-randomness.

\subsection{Input Sources}
As we argued, true randomness cannot be used in a randomness beacon for our setting;
and since we use a deterministic algorithm to convert input to output, the input must have certain qualities.
The user must be able to reason about it and trust it.

Here, there are two approaches to input:

\begin{description}
    \item[Publicly Available Sources] Using a publicly available source that everyone can agree on the value of, such as bitcoin transaction hashes, stock market data or lottery winning numbers from several international lotteries.
The user must trust the source.
Problems: The sources dictate the output rate, and sources can be compromised, and provides no guarantee / does not really solve the issue (the users should also make a bitcoin transaction, have a stock company, or observe the drawing from the lotteries to make sure everybody is not colluding against them); although it is far more unlikely that any adversary will be able to control stock markets, lotteries, and the entire bitcoin network.

    \item[User Input] In essence, the only thing a user can trust is themself.
Therefore, the user can be allowed to directly provide input to the computation.
The user should then be able to verify that their input has been used as part of the computation.
If they can verify that, they know the number is good.
If their number is not part of the computation, they should not use the number.
This seems like a reasonable assumption.
In other words, if a given user needs to use the number, they should provide an input.
\end{description}

We will use the latter (user input).
It is important to stress that a user should only use a given output if they can verify that the input of a trusted party has been part of the computation --- usually the only trusted party is the user itself.


\subsection{Beacon Operation}
We identify a total of four ways in which a beacon are typically operated: 

\begin{description}
    \item [\gls{mpc}] Users use multiparty computation to produce randomness. While notable examples of such beacons exist, they either have problem scaling outside of small groups or require honest majorities. This makes them less suited for public use, where we do not control the amount of users or their identities. 
    \item [Autocratic Collector] A single entity collects and publishes randomness with no option for verification of the output. Absolute trust in the entity is required to trust the output. 
    \item [Transparent Authority] A single entity collects inputs and publishes it with a focus on transparency - users can verify that the beacon behaves according to protocol. Typically uses publicly available input or user inputs. 
    \item [Data Publisher] An entity outputs or refers to publicly available data, that can be used to generate random numbers. They also provide the algorithm to do so, allowing users to generate their own random numbers. 
\end{description}