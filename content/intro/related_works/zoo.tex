\subsubsection{A random zoo: sloth, unicorn, and trx}%
\label{sub:random_zoo}
\citet{randomzoo} implement a protocol reminiscent of a beacon as a way to generate random numbers and parameters for \gls{ecc}.
They produce random numbers by collecting data from a variety of sources before running it through a time-hard delay function called \textit{sloth}.
Sloth is a strictly sequential function which is orders of magnitude faster to inverse for verification.
The time-hardness prevents last-draw attacks, as attackers have to dedicate large amounts of time to compute how to bias the output, during which new inputs can render their efforts pointless.

The combination of input collection from multiple sources and then computing the output of a delay function, is presented as the \textit{unicorn} protocol.
This protocol resembles that of the \emph{transparent authority} beacon computation model, and is done by a single entity.
In the paper, \citeauthor{randomzoo} suggest feeding \textit{sloth} with an aggregation of user inputs, such as tweets, and private input sources such as a sampling of weather data.
While they guarantee random unpredictable outputs even if all other users are malicious, they do not explore the scenario of a malicious operator, who colludes with adversarial users.
Furthermore, the unicorn protocol lacks a concrete implementation and security analysis.

To generate the aforementioned \gls{ecc} parameters, a final protocol named \textit{trx}\footnote{pronounced like the T.\ rex dinosaur} is presented, which utilizes the output of the unicorn --- thus completing the zoo analogy.

The \emph{sloth} delay function will be a key part of our randomness beacon.
However, the supporting structures driving the beacon will be different.
We go in greater detail with the security of both the protocol and the beacon operator, and in particular assume the beacon operator can be malicious.
We expand on this throughout the paper.

