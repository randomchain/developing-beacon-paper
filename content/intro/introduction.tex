\section{Introduction}
%Randomness is useful for many cases, but can be difficult to trust, as it is hard to guarantee that a random number really is \emph{random}, and not biased towards anyone's benefit.

\emph{Randomness beacons}, services emitting unpredictable random values at fixed intervals, have been around for a long time.
In 1983 Michael O.\ Rabin coined the term and used one to add probabilistic security in several protocols~\cite{rabin1983transaction}.
In this definition, a randomness beacon was to be seen as an impartial third-party trusted to be unbiased towards any outcome.
%Soon, however, cryptographically secure variants of Rabin's protocols emerged~\cite{BGMR} that did not rely on a randomness beacon.
As such, Rabin's beacon is to be trusted, i.e.\ you should trust the beacon operator (the entity running the beacon service) to not be biased, because you cannot verify that they are unbiased.

For quite a while, randomness beacons did not receive much attention, probably because alternatives to Rabin's protocols not requiring a trusted beacon were used instead (such as~\cite{BGMR}).
Circa 2010 a renewed interest in beacons was seen as an increase in beacon-related literature, and the trend in this new literature was to soften the need to trust the beacon operator.
We believe it may have been a reaction to the financial crisis, which led the global discussions towards questions of trust in governments and corporations.
In other words, people had their eyes opened to the fact that \emph{trust} can be an issue in itself, and that removing the need for trust in any one entity could, in some cases, be beneficial.
As an example, cryptocurrencies emerged shortly after (and some might argue as a direct consequence of) the financial crisis, and a sharp rise in popularity of blockchains was seen --- two technologies that seek to facilitate cooperation of mutually distrustful users.
%The literature also contains a wealth of examples that combine blockchains and beacons to produce randomness either based on a blockchain, or as a smart contract running on a blockchain.

Conceptually, randomness beacons seem to fit this environment of minimizing the need to trust, as a randomness beacon is acting as an impartial party.
However, the \enquote{old} way, requiring users to trust the operator, simply shifts the trust issue to the centralized entity of the beacon operator.
If anyone is using a randomness beacon, it is specifically because they do not wish to trust some entity.
Therefore, we believe trusting the randomness beacon is a moot point --- the two entities might collude against the na√Øve user.
Consequently, we only consider the kind of randomness beacon that has been proposed in the recent literature --- the one that does not require users to trust it.

%Therefore, the interesting part is in the recent literature, with promising ways of implementing a beacon in such a way that the beacon operator does not need to be trusted either.

%The body of this work will be to discuss, design, and implement a beacon following the concept of not requiring users to trust it.% Before doing so, let's take a small detour and talk about potential use cases and the motivation for using a beacon at all.

\subsection{Terminology}
As discussed, we see two distinct groups of randomness beacons: the ones which require users to blindly trust the beacon operator (a la Rabin's original beacon); and the \enquote{new generation} randomness beacons of recent literature, which convincingly prove to all users of the beacon that nothing fishy happened during the \enquote{generation} of the random output.

In this work, we will use the terms \enquote{randomness beacon} and \enquote{beacon} interchangeably --- both will equivalently refer to the second, new generation group of randomness beacons, those not requiring trust, unless clearly stated otherwise.
We will not dwell too much on the original group of randomness beacons; those requiring trust in the operator.
However, we cannot ignore this group for the sake of history and examples of what not to do, and in these few cases we will make it clear that we are talking about the first group, the \enquote{trust-requiring beacons}.

\subsection{Trust Assumptions}
Knowing nothing about the design or construction about the beacon, the only assumption of trust we reasonably can make is:
\enquote{Everybody, including the beacon operator, is secretly colluding against you and willing to put an unlimited amount of money and resources towards manipulating or biasing the process for their own benefit}.

%The only one you can trust is yourself, and this extends to the beacon. If you have not influenced the beacon output, it should be considered biased against you by default.

\subsection{Use Cases}

\mtjnote{Ideas needed: How to structure this section?}

%In which environments are beacons suitable? Users of the beacon output may be considered private individuals, scientists, companies, and corporations.

%As a side note, all examples of use cases mentioned in this section also work with a trust-requiring beacon, \emph{if} it is reasonable to assume users are willing to trust the beacon.

%While we like the concept a randomness beacon offers (a tool to remove trust), we struggle to follow many of the use cases proposed in the literature. Classic use cases include

%\mtjnote{Write about zk-snarks}

%This recent literature presents some promising ways of creating an unbiasable beacon. However, there still exists no \enquote{killer} \enquote{real-life} use cases of a randomness beacon.
%We see many potential use cases, and present a variety of them with roots in the literature, before constructing a beacon of our own and performing a security analysis on it.

\subsection{Beacon Definition}

A randomness beacon emits an unpredictable random value at a fixed interval, e.g.\ every five minutes.
The beacon is constructed in a way that allows all users of it to see that the emitted value is indeed unpredictable and does not favor any particular outcome.
In other words, users should not need to trust the beacon operator to do what the beacon operator says they are doing, but the user can immediately see that nothing fishy has happened.

\subimport{}{simple_beacon_fig.tex}

\subsubsection{A Note on Randomness}
Some randomness beacons claim to produce true randomness~\cite{nistbeacon}.
In our setting, producing true randomness is not an option.
True randomness is often produced by observing quantum mechanical effects.
These observations cannot be repeated by users (they are, after all, truly random and non-reproducible), and therefore users cannot make sure that the value is indeed from observing the quantum mechanical effect and not crafted by the beacon operator.
As such, the users need to blindly trust the beacon operator, which in the case of \gls{nist} can be hard given their history~\cite{nytimes-nsabackdoors, nytimes-nsaconstants, nist2014backdoor}.

Fortunately, the vast majority of use cases do not actually require true randomness.
Far more desirable is the side effect of producing randomness: \emph{unpredictability}.
As long as the output is unpredictable for all parties including the beacon operator, we do not really need true randomness, and the beacon output can be produced by a deterministic algorithm.
And if implemented correctly, deterministic pseudo-randomness is just as good for virtually all use cases and provides a good level of unpredictability.
%No true randomness is necessary but we care deeply about the unpredictability from deterministic pseudo-randomness.

\subsubsection{Input Sources}
As we argued, true randomness cannot be used in a randomness beacon for our setting;
and since we use a deterministic algorithm to convert input to output, the input must have certain qualities.
The user must be able to reason about it and trust it.

Here, there are two approaches to input:

\begin{description}
    \item[Publicly Available Sources] Using a publicly available source that everyone can agree on the value of, such as bitcoin transaction hashes, stock market data or lottery winning numbers from several international lotteries.
The user must trust the source.
Problems: The sources dictate the output rate, and sources can be compromised, and provides no guarantee / does not really solve the issue (the users should also make a bitcoin transaction, have a stock company, or observe the drawing from the lotteries to make sure everybody is not colluding against them); although it is far more unlikely that any adversary will be able to control stock markets, lotteries, and the entire bitcoin network.

    \item[User Input] In essence, the only thing a user can trust is themself.
Therefore, the user can be allowed to directly provide input to the computation.
The user should then be able to verify that their input has been used as part of the computation.
If they can verify that, they know the number is good.
If their number is not part of the computation, they should not use the number.
\mtjnote{Rewrite this sentence so it fits in:} In addition, even if you have influenced the output, given enough time resources to work around your influence, the output could still be biased against you.
This seems like a reasonable assumption.
In other words, if a given user needs to use the number, they should provide an input.

\end{description}

We will use the latter (user input).
It is important to stress that a user should only use a given output if they can verify that the input of a trusted party has been part of the computation --- usually the only trusted party is the user itself.

\subsubsection{Operation Approaches}
We identify a total of four ways in which a beacon are typically operated:

\begin{description}
    \item [Autocratic Collector] A single entity collects and publishes randomness with no option for verification of the output. Absolute trust in the entity is required to trust the output. This type is directly synonymous with the trust-requiring beacon that we described earlier.

    \item [Specialized \acrshort{mpc}] Users utilize \acrfull{mpc} to produce randomness. While notable examples of such beacons exist, they either have problem scaling outside of small groups or they require honest majorities. This makes them less suited for public use, where we do not control the amount of users or their identities.

    \item [Transparent Authority] A single entity collects input and publishes it with a focus on transparency --- users can verify that the beacon behaves according to protocol. This type uses publicly available input or user inputs.

    \item [Data Publisher] An entity outputs or refers to publicly available data, that can be used to generate random numbers. They also provide the algorithm to do so, allowing users to generate their own random numbers.
\end{description}

\subsection{Contributions}
\mtjnote{Todo: Contributions}
