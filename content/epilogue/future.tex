\section{Future Works}%
\label{sec:future_works}
This section outlines next steps to explore regarding our randomness beacon.

\subsection{Usability Applications}%
\label{sub:usability_applications}
To ease users interaction with the beacon and the process of verification, some usability applications could be implemented.

This could be in the form of a \enquote{client} application, which facilitates input submitting and output verification.
Interacting with such an application could from the users' perspective be as simple as running it in the background, while the application constantly inputs to the beacon, and verifies both inclusion of said input and correct computation of the output.
The user could then at any time poll the application for a \emph{verified} beacon output.
In this scenario, the user would inherently need to trust the application to not be acting malicious.

Another usability application, taking a far simpler approach, could be a simple verification service.
It would allow users to painlessly check if their input was used in a beacon output.
Since our beacon uses a Merkle tree for storing the inputs, the verification service could provide users with proofs of inclusion, without them needing to fetch the entire set of used inputs.
In fact, user would at most need to download $\log{n} + 1$ nodes in the Merkle tree, to validate the proof; this is further explained in \vref{ssub:combining_inputs}.
Users could then correlate the valid proof with the output of the beacon for complete verification.

\subsection{Incentives and Use Cases}
We have assumed that our beacon will be run by an interested authority as a greater good. In our design, the speed of the beacon operator's computer will not be significantly important. The computation is only a service to save all users the CPU time of computing it themselves. As such, the computation of the delay function should only happen so fast that users will not be annoyed and run the delay function themselves --- there is no loss of security by waiting a bit for the beacon operator's output. The only thing that matters in the design of our beacon is the time from a user inputting and the user receiving a commitment. This duration should be lower than what the user believes is the fastest possible execution of the delay function by any computer in the world.

Because of the fact that speed does not matter \emph{much}, it enables a relatively low entry barrier. We have imagined universities or privacy-minded corporations to run the beacon as a public good. It will not require much besides a reasonably powerful server, where the single-core performance and number of cores will be the main resources to consider. These authorities' willingness to run a beacon is purely speculative, and as such we do not know if these authorities are even interested in running a beacon. Therefore, incentives for running a beacon will need to be investigated further. A strong incentive to run a beacon is compelling use cases. As such more use cases, and incentives for using a beacon as a cryptographic primitive, should also be further explored, beyond our discussions in \vref{sec:applied_use_cases}.