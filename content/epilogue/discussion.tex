\section{Discussion}%
\label{sec:discussion}
This section is dedicated to discussing some the topics that have come up during our work.
%MostGenericMetaText

\mtjnote{Incentives to run the final system... Isn't this a good evaluation-thing?}

\subsection{Operation --- formerly known as something}
We designed our beacon to be run by a single operator - however, we also considered the possibilities of the operator being malicious, and users losing confidence in a given operator.
This means there is a real possibility that other operators can arise to replace operators users lose confidence in. Since this is vital to the availability of a beacon, we consider ease of deployment to be vital to our beacon. Given that the beacon is run as a greater good, users should not need to make any large investments to become operator. Making the transition to operator as easy possible facilitates our desired user behavior. This also means that the beacon should be easy to deploy for a new operator.

\subsection{Output Dependency}
We currently suggest a variety of use cases for our beacon, but we should include one important caveat --- users should not have a critical dependency on the output.

This is because we can not guarantee that there will always be an output time due to the possibility of attacks on the availability.
Instead, users should aim towards being flexible with when they need to use an output. An example could be to use the \textit{next} output that they see a timely commit containing their input to. Only then will they be certain that the output is not biased.

While this does make the beacon more difficult to use, in the current design it is a necessary precaution to using it.

\subsection{Alternative Delay Functions}
We currently use a time-hard function to compute our randomness. This provides us some indication of the computational effort needed to correctly produce a random number, and thus makes it harder to cheat.
However, requirements on processing power is not an insurmountable obstacle for motivated attackers. An excellent example of this is the bitcoin blockchain, where mining consists of solving a computational puzzle by repeatedly hashing. Here, \glspl{asic} have allowed great speedups in the mining process, which has resulted in greatly raised mining difficulty, and ordinary computers becoming comparatively useless for mining purposes.
If any party was to develop \glspl{asic} for our delay function, they would be able to solve it much faster than any other party. This would greatly diminish the security provided by the delay function, and open up for last-draw attacks from the party with the \gls{asic}.

One way to mitigate this would be to greatly increase the difficulty of the delay function, like it has been done in bitcoin. However, this would have the side-effect of making the function much more costly to compute for any party without \glspl{asic}. This could even include the beacon operator, which would significantly impact operations.

Another way to mitigate this would be to use a delay function that was also memory-hard, i.e.\ required large amounts of memory to compute. This would make it resistant to \gls{asic}-equipped adversaries, as these have very small amounts of memory to optimize for speed. While the function would require more resources, it should still be computable for an ordinary computer, but resistant to \gls{asic} and the massive associated speedup.

\subsection{Salting}

One thing we considered in the design of the beacon was having the operator add a salt to the inputs.
This would make the operator the only party capable of computing the output, which would prevent outsiders from pre-imaging and performing last-draw attacks without help from the operator.

On the other hand, this would give the operator even more power. Specifically, he could easily perform withholding attacks, as he was the only party capable of producing the \textit{genuine} beacon output. However, this could be mitigated by having the operator published a timed commitment to the salt alongside the inputs --- this second commit could then be revealed by outsiders given enough time, which would prevent the operator from withholding once both commits were published.

\subsection{Smart Contracts}
Distrustful environments are an obvious settings for a randomness beacon, and one of the most obvious types of these are blockchains. As such it is interesting to consider implementing our beacon in a smart contract on a blockchain.

There would be some definite benefits to this, namely that it would remove the need for a single operator, which removes some threats towards the beacon. In addition, it would be much harder to \acrshort{dos} attack the beacon, as it would be run by the entire network.

However, a central aspect of our beacon is practically incompatible with the nature of smart contracts. The delay functions we use are computationally intense. Smart contracts need to pay for each computation they make, which would make the beacon very costly to run.

This ties the beacon into the monetary incentive structures that dictate smart contract behavior. Running a smart contract equivalent of our randomness beacon would be extremely expensive. However some parts, like the verification process, are nowhere nears as heavy, and could possibly be implemented.

This has also been examined in the literature, where \citet{bunz2017proofsof} implements an Ethereum smart contract to publish and challenge the output of the beacon. The beacon requires money to publish outputs on the blockchain, and users must pay to challenge a given output. \citet{bunz2017proofsof} provide a detailed structure of incentives the beacon should provide to ensure correct behavior. This illustrates the difference in structure that follows implementing part of a beacon in a smart contract.

In addition, since parts of the beacon would still be off-chain, those parts would still be dependant on an operator and vulnerable to \acrshort{dos} attacks.

%The RanDAO~\cite{randao} is an example of a working randomness beacon in an Ethereum smart contract. This in turn means that the beacon is not run by an operator, but by the network as a whole. However, the operation of the beacon is still dictated by financial incentives. At each block, users can contribute commits to inputs, alongside a small deposit. They must then later reveal the committed values, or lose their deposits. If no users contribute or reveal their commitments, the beacon will not output any value at that block.

%Smart contracts pay a small fee for using the output of the RanDAO, the profits of which go to the contributing users. Again we see a strong tendency towards having financial incentives drive the correct behavior of users, which ultimately requires the beacon to demand payment.

Another thing to consider is that everything that occurs on a blockchain occurs because someone put it into a block. This is typically the job of miners, who have different interests than other users, as they want to include the transactions that give them the greatest rewards for the block. Thus a user would have to pay a competitive fee to interact with a beacon on a blockchain.

If we also consider the trust assumption of everyone being against the user, they would have to mine the block themselves to guarantee their interaction, which is a very steep requirement.
