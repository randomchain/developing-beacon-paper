\section{Conclusion}%
\label{sec:conclusion}

% Rehash the problem
% But under no circumstance just copy something from the introduction or abstract. Now it is usually possible to use concrete numbers and terminology.
This work has been based partly on an interest in randomness beacons, and partly on us wondering why these constructions are not implemented for real world usage.

While we take inspiration from previous work and literature, designing a randomness beacon from ground up is no simple feat.
We have designed a system which is based on simple principles.
However, simple systems still have many details when considering the implementation.
We have made conscious choices regarding communication framework, communication patterns, compromises between verbosity and base essentials in communication, and put much thought into the practicalities of running our beacon.
In particular, we have parallelized the beacon operation to have a continuous input stream and regular output, and outline a formula for finding the number of computation nodes.
Further, we scale input collecting by enabling horizontal scaling, and even improve usability of the system by allowing these input collectors to collect from a variety of sources with easy access for users.

We have shown the possibility of instantiating a randomness beacon with sensible guarantees for any single user. In particular, given their random input to the beacon, they can easily and rapidly verify the computation, and decide if they they deem it trustworthy.

% Rehash our contributions --- what is significant?
We have performed a security analysis of randomness beacons to identify threats towards them, and incorporated counters for them in the design of our own beacon. We design the beacon to mitigate a variety of attacks.

We have refined and extended the work of \citet{randomzoo}.
In particular, they propose delay functions and provide a short discussion on the repercussions of the users' trust assumptions by using such delay function.
We refine the usage of delay functions to allow all users to run the delay function in parallel with the beacon operator, or to run it if the beacon operator (maliciously or not) performs an output withholding attack.
We extend the discussion of users' trust assumptions by providing a succinct formula, which only depends on two timestamps and what the user believes is the fastest possible computation.

Further, we have proposed a parallelization technique for the beacon pipeline, such that input collection is a continuous stream. This allows the output frequency to be considerably increased, and allows for adjustments to the ratio between input collection time and computation time. At the same time, we note that computation components can be reused for subsequent computations instead of instantiating new services.

We have also explored the applications of our randomness beacon as a cryptographic primitive in a variety of use cases. We presented ceremonies for using our beacon to obtain public randomness in a secure way. The use-cases range from lotteries to crypto system bootstrapping, and each has a ceremony associated with it.
As such, we have not only investigated the gap in literature towards a practical beacon implementation, but also discussed the practicality of the beacon in context.

\mtjnote{Multiple input output channels?}

% Assess the significance of contribution

There is need for more work, especially in regards to further increasing the guarantees for the users.

% Call to arms: USE THE BEACONS.
% % What are the limiting factors? People don't care? ikke nok use cases hvor der allerede er trust involveret

% Warnings? E.g.\ do not use for key generation, etc?
