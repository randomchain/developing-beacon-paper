\subsection{Improving Protocols}
Throughout the literature on randomness beacons there has been a prevailing theme: securing algorithms and protocols that would otherwise be insecure without public randomness. This allows for the use of faster and less complicated protocols as long as randomness is available from a beacon.

The theme has its roots in the first paper on randomness beacons \cite{rabin1983transaction}, as they were originally conceived as a means to protect transactions. Here the availability of trustable random numbers allows for protected transactions that do not rely on a third party besides the beacon.

Beacons have also been suggested as a way to secure smart card authentication protocols. \citet{fischer2011publicrandomnessservice} suggest using a smart card challenge-response authentication protocol based on modular square roots and Blum integers. The protocol itself is potentially vulnerable to chosen ciphertext attacks from the card reader, that could obtain the cards secret key. Using a randomness beacon, they can ensure that the challenges are randomly generated, and the reader is unable to steal the private key. However, they fail to address the fact that the random number would need to be signed by the beacon for the card to trust it, and the card would need to verify this signature. The question then becomes whether the card could not simply replace the insecure challenge-response protocol with the secure signing protocol it would need to verify.

We also see that beacons have been used to increase performance of certain protocols. ZK-SNARKs require a bootstrapping phase to generate a common reference string for those that use the system. This process can be extremely complicated in order to avoid manipulation, and is hard to scale beyond a handful of people. \mtjnote{ZKSNARK scaling paper cite} uses a randomness beacon to perform this bootstrapping in an MPC-protocol that scales far beyond previous attempts while still generating an unmanipulated common reference string.

In fact, many cryptographic schemes contain hard-coded constants, which ultimately are generated in \enquote{some way} by the algorithm designer, or by using \enquote{nothing-up-my-sleeve}-numbers (e.g.\ the SHA1 of $\pi$).
The former way leaves vulnerabilities of backdoors~\mtjnote{dual-curve source}, and in the latter case \mtjnote{SOURCE} argues there is a great amount of freedom in choosing seemingly innocent constants.
Instead, it could be announced by the algorithm designers, just like the lottery entity, that a future randomness beacon output will be used to generate the constant in the way \mtjnote{million dollar curve cite} describes.