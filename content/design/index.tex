\section{Beacon Design}

\mtjnote{Write that we prioritize several design goals: Security, scalability... We probably also think of Mother Earth to not waste electricity (as Bitcoin arguably does).}

\mtjnote{SWEBOK: \enquote{Design for security is concerned with how to prevent unauthorized disclosure, creation, change, deletion, or denial of access to information and other resources. It is also concerned with how to tolerate security-related attacks or violations by limiting damage, continuing service, speeding repair and recovery, and failing and recovering securely. Access control is a fundamental concept of security, and one should also ensure the proper use of cryptology.}}

\mtjnote{We need to meet our requirements and take the previously found security concerns into account and design a suitable beacon that tries to overcome as many problems as possible.}

To meet the requirement of extendability, we use a \gls{soa} to design the beacon.
This architecture splits systems into application components, also called services.
These services serve a single purpose, i.e.\ they each logically represent part of the activity needed for the entire system and have a specified outcome.
Communication between components is done according to a well-defined protocol, such that no one component is reliant on the inner workings of another;
a component, or service, should be seen as a self-contained black box.

This architecture provides loose coupling in the system and also allows for easier fault tolerance since services, being a black box, are easily replaceable on failure.
However, as services need knowledge about other relevant services, some mechanism for service discovery is typically deployed.
This can be a single point of failure, but mitigated by having several of these. \mtjnote{Sass has the good source of having two of these and that in \enquote{95 \%} of cases, it is sufficient.}
\fxnote{expand on this and how it can be decentralized}

\subsection{Components of a Beacon}
\label{sub:components_of_a_beacon}
In the \gls{soa}, a single instance of a randomness beacon will consist of the following (see \cref{fig:beacon_arch}):
\begin{description}
    \item[A number of input collector services] which can collect from a myriad of different sources.
    \item[An input processing service] which aggregates the input from all the collectors.
    \item[A computation service] which commits to the aggregated input, runs the computation to generate an output.
    \item[A number of publishing services] which can publish the commitment, output, and any relevant proofs, to different outlets.
\end{description}

\subimport{}{beacon_architecture.tex}

\subsection{Pipeline}%
\label{sub:pipeline}
In our \gls{soa}, %Besides the \gls{soa}, we also utilize a pipeline architecture to design the beacon.%
data only flows one way through the system, and each component performs an independent transformation.
This effectively means that a beacon is a pipeline where data flows into the system as inputs, is processed, transformed to a random output, and lastly published.

The pipeline architecture can be seen as a specialization of the \gls{soa} pattern, since each step in the pipeline is a service as defined in a \gls{soa}.
When considering the system as a pipeline some restrictions are imposed compared to the more generic \gls{soa}, in that data only flows in one direction.

The pipeline also allows for parallel operation, i.e.\ input collectors can run continuously as can the computation service.
This effectively means that we can reach the highest possible output of randomness given a single computation service.
One might argue that several computation services slightly offset in start time, could output more frequently, but this would by our design be considered several different beacons.
\mtjnote{Make figure explaining this parallelization. Lego-klodser sat sammen.}

In some scenarios a beacon may consist of multiple computation services, as a mean of redundancy, as long as each computation is run on the same input.
The same can be said about input processors, where a beacon may need redundancy to likewise avoid a single point of failure.
This brings forth the issue of consensus about which input to use\msmnote{out of scope or explain solutions?}.

\mtjnote{Rewrite all parts of this section to say when something from STRIDE has been solved or mitigated.}

\subsection{Security Design}

\mtjnote{This section deals with some problems introduced by our chosen architecture and some parts of STRIDE.}

When designing a composable system such as our randomness beacon, it is important to take into account, the inter-component communication.
From a security aspect, splitting up the system from a monolithic self-contained architecture to a service oriented kind, exposes a myriad of new attack surfaces.
For example this architecture can potentially make it possible for adversaries to cut off parts of the system, by means of \gls{dos} attacks.
Moreover the protocol used to communicate from service to service, must be secure in a way that prevents adversaries from being able to undetectably manipulate the messages.

In the case of a randomness beacon, the security also embodies the operators ability to predict or manipulate the output.
This means that we need some mechanism of preventing the operator from performing last-draw attacks disguised as regular user inputs, or excluding certain inputs to alter the output.
Moreover we also want to prevent the operator from being able to initiate multiple beacon computations, and then only publish the output which benefits the operator the most.

Generally, these concerns can be mitigated by enforcing a \gls{cco} workflow in the beacon protocol.
This effectively means that each published output is paired with a commitment which can be used in the verification of the beacon.
The operator must publish the commitment a significant amount of time before the output is published --- otherwise, the beacon operator could just publish a commitment to any desired output. Furthermore, the operator is limited to a single commitment --- otherwise the operator could publish several commitments and only publish the most desireable output.

To guarantee that the time between publishing the commitment and output has been spent on computing the output, we utilize a delay function.
Delay functions require a given amount of time to run and are inherently sequential, meaning that they cannot benefit from parallel execution.
When deploying delay functions in randomness beacons it is important to keep verification in mind.
A user should be able to run the delay function in reverse to confirm that a commitment matches the output.
To avoid having to require each user to execute the full delay function, we use a flavour of delay functions which are asymmetrically hard, i.e.\ hard to compute but easy to verify.

The combination of these concepts, \gls{cco} and a delay function, effectively gives the following workflow for each cycle of the beacon:
\mtjnote{Make a nice figure of this with $t_{-1}, t_0, t_1$... and describe time intervals.}

\begin{enumberate}
    \item Collect inputs
    \item Process inputs
    \item Publish commitment
    \item Compute output
    \item Publish output
\end{enumberate}

\mtjnote{Write here what the commitment is. It includes the hashed inputs. It is a good discussion when to release the inputs. It would also be possible to release the inputs together with the output --- this allows the operator to know that only HE can calculate the output and nobody can know the result beforehand. On the other hand, this allows the operator to provide early access to paying customers. We will therefore release all (hashed) inputs when releasing the commitment.}

The delay function also partially protects against last-draw attacks by malicious attackers. A last-draw attack would attempt to bias the output by crafting their own input so as to produce favorable randomness. To do this, the attacker needs to compute the result of adding a specific input as the last input. Delay functions make this significantly more difficult to attempt due to the time needed to compute the result. Given a delay function that takes five minutes to complete, an attacker must dedicate five minutes of processor time to any given input he attempts to use. This means the attacker must dedicate large amounts of resources to perform any significant amount of attempts, and more importantly: if a single input is added to the beacon within that five minute period, all of the attackers work will be null, and he will be forced to restart.

\mtjnote{The beacon is secure because:}
\mtjnote{%
The operator does not know the individual inputs before receiving them
He commits to using the inputs, i.e.\ he cannot change the order of them to his own benefit.
What keeps him from trying out multiple commitments before publishing one?
The slow hash function ensures that he cannot try excessively many commitments.}
