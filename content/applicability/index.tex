\section{Applicability}
\fxnote{How our beacon fits in other contexts. E.g. a discussion about its merit in smart contracts. Also potentially a demonstration of a use case using the beacon.}

\subsection{Case Study: Lotteries}
\fxnote{Introduce an example with three friends, who wants to settle something by randomness. They can use the solution of inputing to the beacon at the same time, and then with high probability, there will be an output which was made from all three friends' input. (Practically, they should probably each provide input every 30 seconds for a few minutes to increase their chances of an output with all three inputs present --- they also need to commit to their input).}

\fxnote{Then turn to an example of a lottery entity with a 1000 participants. Here, we cannot wait for an output containing the input of all 1000 participants. To relax this requirement, the lottery entity should concatenate all outputs made in the time the lottery is running. When the time is up (and a winner needs to be found), they hash the concatenated outputs --- and this hash is the random value. In order to prevent the lottery entity from performing a last-draw attack (i.e. \enquote{Whoops, this last output didn't make it to our computer because of latency}), they could either do a short delay function, OR another scheme: Shortly before the time is up, the lottery entity inputs a so-called stop input to the beacon. This stop input is a, by the lottery entity, signed message --- a message which has been revealed at the very start of the lottery. The signed version of this message is included 1 minute before deadline, and the signed version is released. Everybody can check that this signature is indeed from the lottery entity and that the message is what they claimed in the start. The output containing this stop message will mark the last output. This is safe because there are other inputs in this last output that the lottery entity could not influence or predict.}