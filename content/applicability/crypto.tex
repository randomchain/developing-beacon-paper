\subsubsection{Cryptography}
Cryptography also contains use cases for our beacon, namely parameter generation and protocol bootstrapping.
Many cryptographic protocols require some parameters to initialize.
Choosing these can be a lengthy process~\cite{mpcsnarks}, but also requires a great deal of trust as they could contain backdoors~\cite{nist2014backdoor}.

Alternatively the parameters could be pseudo-randomly generated by a generator that only generated good parameters. The generator could then be seeded by a randomness beacon~\cite{baigneres2015trap}.

This could be accomplished much like the large lottery ceremony previously presented, by announcing a collection period and stop message. Using all inputs collected within that period as the seed would then make a wide variety of interested parties able to input to the parameters, giving them some measure of trust in the protocol.

Of course, this would also require the parameter generator to not be malicious, but that is outside our scope.


Another excellent use case is bootstrapping for \gls{zksnark} systems. Such systems require a \emph{common reference string} that must be generated as part of the bootstrapping process. Generating this string can be an extremely complicated process, as the trust of the entire system rests on the string. Should any party possess the numbers from which the string was generated, they can effectively fake proofs of anything, undermining the system.

Due to its importance and complexity, it is hard to scale such a process, which in turn requires more users to trust the participants. Using a randomness beacon can allow the process to scale far beyond the norm, as demonstrated by~\citet{mpcsnarks}. This makes it possible for more users to contribute to the system which makes it easier to scale.

They present a \acrshort{mpc} protocol for \acrshort{zksnark} bootstrapping. The protocol operates across a number of rounds, and each round includes an input from a beacon.

Practically, each round could be organized around a number of beacon outputs containing specific \textit{round number} messages. These messages would be signed and committed similarly to previously mentioned stop messages, only with several rounds.

This would make it possible for each participant to contribute to the beacon each round, while giving the same guarantees as the original protocol. However, it would tie the \acrshort{mpc} protocol's progression to the beacon, which could significantly reduce its speed. An adversary could even \acrshort{dos} attack the beacon to completely halt the protocol.
The speed issue could also be mitigated by using a beacon with shorter collection and computation phases.
