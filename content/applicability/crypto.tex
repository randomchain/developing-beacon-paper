\subsection{Cryptography}
While we see our beacon as a cryptographic primitive, around which ceremonies can be constructed, other cryptographic concepts can benefit from using a randomness beacon, namely parameter generation and protocol bootstrapping.
Many cryptographic protocols and schemas require some parameters to initialize.
Choosing these can be a lengthy process~\cite{mpcsnarks}, but also requires a great deal of trust as they could contain backdoors if crafted meticulously~\cite{nist2014backdoor}.

Alternatively the parameters could be pseudo-randomly generated by a generator that only generated good parameters.
The generator could then be seeded by a randomness beacon, as described by~\citet{baigneres2015trap}.
This could be accomplished much like the large lottery ceremony by announcing a collection period and stop message.
Using all inputs collected within that period as the seed would then make a wide variety of interested parties able to input to the parameters, giving them some measure of trust in the protocol.

\subsubsection{Bootstrapping Protocols}%
\label{ssub:bootstrapping_protocols}
Another excellent use case is bootstrapping for \gls{zksnark} systems.
Such systems require a \emph{common reference string} that must be generated as part of the bootstrapping process.
Generating this string can be an extremely complicated process as the trust of the entire system rests on the string.
Should any party possess the complete data from which the string was generated they can effectively fake proofs of anything, undermining the system.

The process requires users to trust at least one of the participants of the bootstrapping ceremony. Because of the complexity it is difficult to scale to more than a handful of participants.
Using a randomness beacon allows the process to scale far beyond the norm, as demonstrated by~\citet{mpcsnarks}.
They present a \acrshort{mpc} protocol for \acrshort{zksnark} bootstrapping.
The protocol operates across a number of rounds and each round includes an input from a beacon \mtjnote{please check}.

Practically, each round could be organized around a number of beacon outputs containing specific \textit{round number} messages.
These messages would be signed and committed similarly to previously mentioned stop messages, only with several rounds.

This makes it possible for each participant to contribute to the beacon each round, while giving the same guarantees as the original protocol.
\mtjnote{I think the following text is a bit vague or irrelevant.}
However, it would tie the \acrshort{mpc} protocols progression to the beacon, which could significantly reduce its speed.
An adversary could even \acrshort{dos} attack the beacon to completely halt the initialization of the protocol.
The speed issue could be mitigated by using a beacon with shorter collection and computation phases.
