\subsection{Lotteries}
A classic use for randomness is sampling, however most cases of sampling are performed in environments with some levels of trust.
In these cases, a beacon would not be needed, but without such trust it is.

A lottery is a natural fit for a beacon, as it has incentives to win based on the prizes.
Fundamentally, it is a type of sampling to find a winner, so it provides an excellent foundation of beacon application ceremonies.

We consider ceremonies for two types of lottery applications:
\begin{eletterate*}
\item between a group of friends and
\item with a weekly lottery service.
\end{eletterate*}
We illustrate the differences between the two, and how to structure the use of the beacon to obtain secure randomness.
Finally we consider how to use the beacon for applications that require randomness at a higher frequency.

Consider a group of three friends which organise a small lottery among themselves.
To prevent cheating (however tongue-in-cheek it might be) they decide to use our beacon to pick the winner.
Recall that a user can only trust an output that they have inputted to --- so all three of them must be able to find their inputs in an output to use it.

Practically, each friend announces a commit to a specific input before repeatedly inputting it to the beacon.
They should then take the first output that contains all three of their inputs and use that to determine who wins.

\subsubsection{Large Lotteries}%
\label{ssub:large_lotteries}
While this approach of having everyone input works for small groups, we cannot reasonably expect every participant in large groups to repeatedly input to the beacon until a number is found.

Instead, we consider a weekly lottery that is open for anyone to purchase tickets.
Since we cannot wait for simultaneous inputs from all customers, we instead use the set of beacon outputs produced during the lottery, giving customers a larger time-frame to influence the outcome.
Practically, we need some way to signal the last beacon output to use, so the lottery must announce a commit to a \textit{stop message} at the beginning of the lottery.
This \textit{stop message} must be cryptographically secured, by signing and encrypting it, such that no other party can stop the lottery prematurely.
Further more the organisation behind the lottery should not be able to withdraw from the lottery after inputting the message.

The lottery then collects all beacon outputs published in the duration of the lottery, and combines them for use in the final decision.
This combining should be predetermined such that the output of said operation is as unpredictable as the beacon outputs themselves.
Once it is time to draw the winners, the lottery repeatedly contributes the previously mentioned \textit{stop message} as input to the beacon.
When a commit from the beacon containing that input has been seen, the lottery then announces both the signed version of the message, and its secret value.
The beacon output containing the \textit{stop message} is then the final one used in the aforementioned output combining, which can now determine whom won.

This scheme relies on the lottery being able to end their collection of input securely, and gives four guarantees to users.
\begin{enumberate*}
\item users can verify the presence of the signed \textit{stop message} in the output by checking the beacon commit;
\item users can verify that the \textit{stop message} was sent by the lottery, as they can verify the signature;
\item users can be certain that the lottery did not craft the \textit{stop message} to bias the input in a last-draw attack, as it was committed to at the beginning of the lottery; finally
\item users can be sure that adversaries did not craft a last-draw attack around the \textit{stop message}, as they did not know the secret message beforehand.
\end{enumberate*}

Users will also have a large opportunity to input to the beacon to influence the final draw.
This ceremony extends the \enquote{three friends' lottery} to accept inputs from a large group over an extended period of time.

One could also consider using the customers ticket purchases as input to the beacon, ensuring all customers have influenced the output.

\msmnote{The following leads nowhere, and as I see it, is actually an anti-use case.
Both because casinos will never want fair games, and because the randomness need only be influenced by one player and the slot machine.}

This specific method would also be useful for applications that require high-frequency randomness.
Consider an online casino, where a large amount of people are constantly playing games.
Each of these will require randomness to determine the outcome of their games, but do not have time to wait for relatively slow beacon outputs.
Nor will the gambling users want to actively contribute to the randomness, as they will be focusing on their games.

This will require a high-frequency beacon to constantly provide fresh randomness, as well as some automated method for users to input while playing.
